# apps/billing/models.py
from django.db import models
from django.utils import timezone
from django.core.validators import MinValueValidator
from decimal import Decimal
from datetime import timedelta
# # from tenants.models import  # Temporarily commented Tenant  # Temporarily commented
from apps.accounts.models import CustomUser as User
from apps.patients.models import Patient
from apps.appointments.models import Appointment
from apps.core.utils.serial_number import SerialNumberMixin
import uuid

class ServiceCategory(models.Model):
    """Categories for medical services"""
    # tenant = models.ForeignKey(Tenant  # Temporarily commented, on_delete=models.CASCADE, related_name='service_categories')
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    is_active = models.BooleanField(default=True)
    
    class Meta:
        ordering = ['name']
        verbose_name_plural = "Service Categories"
    
    def __str__(self):
        return self.name


class MedicalService(models.Model):
    """Medical services and their pricing"""
    # tenant = models.ForeignKey(Tenant  # Temporarily commented, on_delete=models.CASCADE, related_name='medical_services')
    category = models.ForeignKey(ServiceCategory, on_delete=models.CASCADE, related_name='services')
    code = models.CharField(max_length=20)
    name = models.CharField(max_length=200)
    description = models.TextField(blank=True)
    base_price = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(Decimal('0.00'))])
    duration_minutes = models.PositiveIntegerField(default=30)
    is_taxable = models.BooleanField(default=True)
    is_active = models.BooleanField(default=True)
    
    class Meta:
        ordering = ['name']
    
    def __str__(self):
        return f"{self.code} - {self.name}"


class Invoice(SerialNumberMixin):
    """Main invoice/bill model"""
    
    SERIAL_TYPE = 'bill'  # For automatic serial number generation
    STATUS_CHOICES = [
        ('DRAFT', 'Draft'),
        ('PENDING', 'Pending'),
        ('PARTIALLY_PAID', 'Partially Paid'),
        ('PAID', 'Paid'),
        ('OVERDUE', 'Overdue'),
        ('CANCELLED', 'Cancelled'),
        ('REFUNDED', 'Refunded'),
    ]
    
    PAYMENT_TERMS = [
        ('IMMEDIATE', 'Immediate'),
        ('NET_15', 'Net 15 Days'),
        ('NET_30', 'Net 30 Days'),
    ]
    
    # Basic Information
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # tenant = models.ForeignKey(Tenant  # Temporarily commented, on_delete=models.CASCADE, related_name='invoices')
    invoice_number = models.CharField(max_length=20, unique=True, blank=True)
    
    # Patient Information
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE, related_name='invoices')
    appointment = models.ForeignKey(Appointment, on_delete=models.SET_NULL, null=True, blank=True)
    
    # Invoice Details
    invoice_date = models.DateField(default=timezone.now)
    due_date = models.DateField()
    payment_terms = models.CharField(max_length=20, choices=PAYMENT_TERMS, default='IMMEDIATE')
    
    # Amounts
    subtotal = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    tax_rate = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal('0.00'))
    tax_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    discount_percentage = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal('0.00'))
    discount_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    total_amount = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    paid_amount = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    balance_amount = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    
    # Status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='DRAFT')
    
    # AI Enhancement Fields
    ai_generated = models.BooleanField(default=False, help_text="Invoice generated by AI")
    ai_confidence_score = models.FloatField(null=True, blank=True, help_text="AI confidence in billing accuracy (0.0-1.0)")
    ai_pricing_optimization = models.JSONField(default=dict, blank=True, help_text="AI pricing optimization data")
    ai_payment_prediction = models.JSONField(default=dict, blank=True, help_text="AI payment likelihood prediction")
    ai_revenue_insights = models.JSONField(default=dict, blank=True, help_text="AI revenue analysis and insights")
    
    # Insurance AI Processing
    insurance_verification_status = models.CharField(
        max_length=20,
        choices=[
            ('PENDING', 'Pending Verification'),
            ('VERIFIED', 'Verified'),
            ('REJECTED', 'Rejected'),
            ('PARTIAL', 'Partial Coverage'),
        ],
        default='PENDING'
    )
    insurance_ai_analysis = models.JSONField(default=dict, blank=True, help_text="AI insurance analysis results")
    
    # Payment AI Predictions
    predicted_payment_date = models.DateField(null=True, blank=True, help_text="AI predicted payment date")
    payment_risk_score = models.FloatField(null=True, blank=True, help_text="AI payment risk assessment (0.0-1.0)")
    
    # Notes
    notes = models.TextField(blank=True)
    internal_notes = models.TextField(blank=True)
    ai_notes = models.TextField(blank=True, help_text="AI-generated notes and recommendations")
    
    # Tracking
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='created_invoices')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Payment Information
    last_payment_date = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['invoice_number']),
            models.Index(fields=['status']),
            models.Index(fields=['due_date']),
            models.Index(fields=['patient']),
        ]
    
    def __str__(self):
        return f"Invoice {self.invoice_number} - {self.patient.get_full_name()}"
    
    def save(self, *args, **kwargs):
        if not self.invoice_number:
            self.invoice_number = self.generate_invoice_number()
        
        # Calculate totals
        self.calculate_totals()
        
        # Update status based on payments
        self.update_status()
        
        super().save(*args, **kwargs)
    
    def generate_invoice_number(self):
        """Generate unique invoice number"""
        from datetime import datetime
        
        today = datetime.now()
        date_str = today.strftime('%Y%m%d')
        
        last_invoice = Invoice.objects.filter(
            created_at__date=today.date()
        ).order_by('-created_at').first()
        
        if last_invoice and last_invoice.invoice_number:
            try:
                last_number = int(last_invoice.invoice_number.split('-')[-1])
                new_number = last_number + 1
            except:
                new_number = 1
        else:
            new_number = 1
        return f"INV-{date_str}-{new_number:04d}"
    
    def calculate_totals(self):
        """Calculate invoice totals"""
        self.subtotal = sum(item.total_amount for item in self.items.all())
        
        # Calculate discount
        if self.discount_percentage > 0:
            self.discount_amount = (self.subtotal * self.discount_percentage) / 100
        
        # Calculate tax on discounted amount
        taxable_amount = self.subtotal - self.discount_amount
        if self.tax_rate > 0:
            self.tax_amount = (taxable_amount * self.tax_rate) / 100
        
        # Calculate total
        self.total_amount = self.subtotal - self.discount_amount + self.tax_amount
        
        # Calculate balance
        self.balance_amount = self.total_amount - self.paid_amount
    
    def update_status(self):
        """Update invoice status based on payments"""
        if self.paid_amount <= 0:
            if self.due_date < timezone.now().date() and self.status == 'PENDING':
                self.status = 'OVERDUE'
            elif self.status not in ['DRAFT', 'CANCELLED', 'REFUNDED']:
                self.status = 'PENDING'
        elif self.paid_amount >= self.total_amount:
            self.status = 'PAID'
        else:
            self.status = 'PARTIALLY_PAID'
    
    def get_status_color(self):
        """Return Bootstrap color class for status"""
        colors = {
            'DRAFT': 'secondary',
            'PENDING': 'warning',
            'PARTIALLY_PAID': 'info',
            'PAID': 'success',
            'OVERDUE': 'danger',
            'CANCELLED': 'dark',
            'REFUNDED': 'primary',
        }
        return colors.get(self.status, 'secondary')


class InvoiceItem(models.Model):
    """Individual items on an invoice with AI enhancement"""
    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE, related_name='items')
    service = models.ForeignKey(MedicalService, on_delete=models.CASCADE, null=True, blank=True)
    
    # Service Details
    service_code = models.CharField(max_length=20, help_text="Service/procedure code")
    description = models.CharField(max_length=500)
    quantity = models.PositiveIntegerField(default=1)
    unit_price = models.DecimalField(max_digits=10, decimal_places=2)
    total_amount = models.DecimalField(max_digits=10, decimal_places=2)
    
    # AI Enhancement Fields
    ai_generated = models.BooleanField(default=False, help_text="Item identified by AI")
    ai_confidence = models.FloatField(null=True, blank=True, help_text="AI confidence in item accuracy")
    ai_source = models.CharField(max_length=50, blank=True, help_text="AI source (e.g., 'emr_analysis', 'text_extraction')")
    ai_extraction_details = models.JSONField(default=dict, blank=True, help_text="Details of AI extraction process")
    
    # Medical Coding
    icd_10_code = models.CharField(max_length=10, blank=True, help_text="ICD-10 diagnosis code")
    cpt_code = models.CharField(max_length=10, blank=True, help_text="CPT procedure code")
    ai_coding_confidence = models.FloatField(null=True, blank=True, help_text="AI confidence in medical coding")
    
    # Pricing Intelligence
    market_price_comparison = models.JSONField(default=dict, blank=True, help_text="AI market price analysis")
    pricing_optimization_applied = models.BooleanField(default=False)
    original_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    
    class Meta:
        ordering = ['id']
        indexes = [
            models.Index(fields=['service_code']),
            models.Index(fields=['ai_generated']),
            models.Index(fields=['icd_10_code']),
            models.Index(fields=['cpt_code']),
        ]
    
    def save(self, *args, **kwargs):
        self.total_amount = self.quantity * self.unit_price
        super().save(*args, **kwargs)
    
    def __str__(self):
        return f"{self.description} - {self.quantity} x {self.unit_price}"
    
    def get_ai_insights(self):
        """Get AI insights for this invoice item"""
        insights = []
        
        if self.ai_generated:
            insights.append(f"AI-identified with {self.ai_confidence:.1%} confidence")
        
        if self.pricing_optimization_applied and self.original_price:
            savings = self.original_price - self.unit_price
            if savings > 0:
                insights.append(f"AI pricing saved ${savings:.2f}")
        
        if self.market_price_comparison:
            market_avg = self.market_price_comparison.get('market_average', 0)
            if market_avg and self.unit_price < market_avg:
                insights.append("Competitively priced below market average")
        
        return insights


class Payment(models.Model):
    """Payment records for invoices"""
    PAYMENT_METHODS = [
        ('CASH', 'Cash'),
        ('CREDIT_CARD', 'Credit Card'),
        ('DEBIT_CARD', 'Debit Card'),
        ('CHECK', 'Check'),
        ('BANK_TRANSFER', 'Bank Transfer'),
        ('INSURANCE', 'Insurance'),
        ('ONLINE', 'Online Payment'),
        ('OTHER', 'Other'),
    ]
    
    STATUS_CHOICES = [
        ('PENDING', 'Pending'),
        ('COMPLETED', 'Completed'),
        ('FAILED', 'Failed'),
        ('CANCELLED', 'Cancelled'),
        ('REFUNDED', 'Refunded'),
    ]
    
    # Basic Information
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE, related_name='payments')
    payment_number = models.CharField(max_length=20, unique=True, blank=True)
    
    # Payment Details
    amount = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(Decimal('0.01'))])
    payment_method = models.CharField(max_length=20, choices=PAYMENT_METHODS)
    payment_date = models.DateTimeField(default=timezone.now)
    
    # Transaction Details
    transaction_id = models.CharField(max_length=100, blank=True)
    reference_number = models.CharField(max_length=100, blank=True)
    
    # Status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='COMPLETED')
    
    # Notes
    notes = models.TextField(blank=True)
    
    # Tracking
    processed_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='processed_payments')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-payment_date']
    
    def __str__(self):
        return f"Payment {self.payment_number} - {self.amount}"
    
    def save(self, *args, **kwargs):
        if not self.payment_number:
            self.payment_number = self.generate_payment_number()
        super().save(*args, **kwargs)
        
        # Update invoice paid amount
        self.update_invoice_payment()
    
    def generate_payment_number(self):
        """Generate unique payment number"""
        from datetime import datetime
        
        today = datetime.now()
        date_str = today.strftime('%Y%m%d')
        
        last_payment = Payment.objects.filter(
            created_at__date=today.date()
        ).order_by('-created_at').first()
        
        if last_payment and last_payment.payment_number:
            try:
                last_number = int(last_payment.payment_number.split('-')[-1])
                new_number = last_number + 1
            except:
                new_number = 1
        else:
            new_number = 1
            
        return f"PAY-{date_str}-{new_number:06d}"
    
    def update_invoice_payment(self):
        """Update invoice payment totals"""
        if self.status == 'COMPLETED':
            total_paid = self.invoice.payments.filter(status='COMPLETED').aggregate(
                total=models.Sum('amount')
            )['total'] or Decimal('0.00')
            
            self.invoice.paid_amount = total_paid
            self.invoice.last_payment_date = timezone.now()
            self.invoice.save(update_fields=['paid_amount', 'last_payment_date'])


class InsuranceClaim(models.Model):
    """Insurance claims for invoices"""
    STATUS_CHOICES = [
        ('SUBMITTED', 'Submitted'),
        ('UNDER_REVIEW', 'Under Review'),
        ('APPROVED', 'Approved'),
        ('REJECTED', 'Rejected'),
        ('PAID', 'Paid'),
    ]
    
    invoice = models.OneToOneField(Invoice, on_delete=models.CASCADE, related_name='insurance_claim')
    claim_number = models.CharField(max_length=50, unique=True, blank=True)
    
    # Insurance Details
    insurance_provider = models.CharField(max_length=200)
    policy_number = models.CharField(max_length=100)
    group_number = models.CharField(max_length=100, blank=True)
    
    # AI Enhancement for Insurance Claims
    ai_pre_authorization_check = models.JSONField(default=dict, blank=True, help_text="AI pre-authorization analysis")
    ai_approval_probability = models.FloatField(null=True, blank=True, help_text="AI prediction of claim approval")
    ai_processing_insights = models.JSONField(default=dict, blank=True, help_text="AI insights for claim processing")
    
    # Claim Details
    claim_amount = models.DecimalField(max_digits=10, decimal_places=2)
    approved_amount = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    deductible_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    
    # Status and Dates
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='SUBMITTED')
    submitted_date = models.DateField(auto_now_add=True)
    response_date = models.DateField(null=True, blank=True)
    
    # Notes
    notes = models.TextField(blank=True)
    rejection_reason = models.TextField(blank=True)
    
    # Tracking
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return f"Claim {self.claim_number} - {self.insurance_provider}"
    
    def save(self, *args, **kwargs):
        if not self.claim_number:
            self.claim_number = self.generate_claim_number()
        super().save(*args, **kwargs)
    
    def generate_claim_number(self):
        """Generate unique claim number"""
        from datetime import datetime
        
        today = datetime.now()
        date_str = today.strftime('%Y%m%d')
        
        last_claim = InsuranceClaim.objects.filter(
            created_at__date=today.date()
        ).order_by('-created_at').first()
        
        if last_claim and last_claim.claim_number:
            try:
                last_number = int(last_claim.claim_number.split('-')[-1])
                new_number = last_number + 1
            except:
                new_number = 1
        else:
            new_number = 1
            
        return f"CLM-{date_str}-{new_number:05d}"


# Backwards-compatible alias: some modules expect a `Bill` model name.
# Keep `Bill` as a simple alias to `Invoice` to avoid breaking imports while
# the codebase is migrated to the `Invoice` name.
Bill = Invoice


class BillingAIInsights(models.Model):
    """
    AI-generated insights and analytics for billing operations
    """
    INSIGHT_TYPES = [
        ('REVENUE_FORECAST', 'Revenue Forecast'),
        ('PAYMENT_PREDICTION', 'Payment Prediction'),
        ('PRICING_OPTIMIZATION', 'Pricing Optimization'),
        ('COLLECTION_STRATEGY', 'Collection Strategy'),
        ('INSURANCE_ANALYSIS', 'Insurance Analysis'),
        ('MARKET_ANALYSIS', 'Market Analysis'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # tenant = models.ForeignKey(Tenant  # Temporarily commented, on_delete=models.CASCADE, related_name='billing_ai_insights')
    
    # Insight Details
    insight_type = models.CharField(max_length=30, choices=INSIGHT_TYPES)
    title = models.CharField(max_length=200)
    description = models.TextField()
    
    # AI Analysis Data
    ai_data = models.JSONField(help_text="AI analysis data and metrics")
    confidence_score = models.FloatField(help_text="AI confidence in insight (0.0-1.0)")
    accuracy_score = models.FloatField(null=True, blank=True, help_text="Historical accuracy of similar insights")
    
    # Associated Records
    related_invoices = models.ManyToManyField(Invoice, blank=True, related_name='ai_insights')
    related_patients = models.ManyToManyField(Patient, blank=True, related_name='billing_ai_insights')
    
    # Impact Metrics
    potential_revenue_impact = models.DecimalField(max_digits=12, decimal_places=2, null=True, blank=True)
    implementation_priority = models.CharField(
        max_length=10,
        choices=[('LOW', 'Low'), ('MEDIUM', 'Medium'), ('HIGH', 'High'), ('CRITICAL', 'Critical')],
        default='MEDIUM'
    )
    
    # Status and Tracking
    is_implemented = models.BooleanField(default=False)
    implementation_notes = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField(null=True, blank=True, help_text="When this insight becomes stale")
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['insight_type', 'created_at']),
            models.Index(fields=['confidence_score']),
            models.Index(fields=['implementation_priority']),
        ]
    
    def __str__(self):
        return f"{self.insight_type}: {self.title}"
    
    def is_valid(self):
        """Check if insight is still valid/not expired"""
        if self.expires_at:
            return timezone.now() < self.expires_at
        return True


class RevenueAnalytics(models.Model):
    """
    AI-powered revenue analytics and forecasting
    """
    PERIOD_TYPES = [
        ('DAILY', 'Daily'),
        ('WEEKLY', 'Weekly'),
        ('MONTHLY', 'Monthly'),
        ('QUARTERLY', 'Quarterly'),
        ('YEARLY', 'Yearly'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # tenant = models.ForeignKey(Tenant  # Temporarily commented, on_delete=models.CASCADE, related_name='revenue_analytics')
    
    # Period Information
    period_type = models.CharField(max_length=10, choices=PERIOD_TYPES)
    period_start = models.DateField()
    period_end = models.DateField()
    
    # Revenue Metrics
    actual_revenue = models.DecimalField(max_digits=15, decimal_places=2, null=True, blank=True)
    predicted_revenue = models.DecimalField(max_digits=15, decimal_places=2)
    ai_confidence = models.FloatField(help_text="AI confidence in prediction")
    
    # Collection Metrics
    collection_rate = models.FloatField(null=True, blank=True, help_text="Actual collection rate as percentage")
    predicted_collection_rate = models.FloatField(help_text="AI predicted collection rate")
    
    # AI Analysis
    revenue_drivers = models.JSONField(default=list, help_text="AI-identified revenue drivers")
    risk_factors = models.JSONField(default=list, help_text="AI-identified risk factors")
    optimization_opportunities = models.JSONField(default=list, help_text="AI-identified optimization opportunities")
    
    # Forecasting Data
    forecast_data = models.JSONField(default=dict, help_text="Detailed AI forecast data")
    trend_analysis = models.JSONField(default=dict, help_text="AI trend analysis")
    
    # Performance Tracking
    accuracy_score = models.FloatField(null=True, blank=True, help_text="Accuracy of prediction (calculated after period)")
    variance_percentage = models.FloatField(null=True, blank=True, help_text="Variance from prediction")
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-period_start']
        indexes = [
            models.Index(fields=['period_start', 'period_end']),
            models.Index(fields=['period_type']),
            models.Index(fields=['ai_confidence']),
        ]
    
    def __str__(self):
        return f"{self.period_type} Revenue Analytics: {self.period_start} to {self.period_end}"
    
    def calculate_accuracy(self):
        """Calculate prediction accuracy after period ends"""
        if self.actual_revenue and self.predicted_revenue:
            variance = abs(self.actual_revenue - self.predicted_revenue)
            self.variance_percentage = float((variance / self.predicted_revenue) * 100)
            self.accuracy_score = max(0, 100 - self.variance_percentage) / 100
            return self.accuracy_score
        return None


class PaymentRiskAssessment(models.Model):
    """
    AI-powered payment risk assessment for patients and invoices
    """
    RISK_LEVELS = [
        ('VERY_LOW', 'Very Low Risk'),
        ('LOW', 'Low Risk'),
        ('MEDIUM', 'Medium Risk'),
        ('HIGH', 'High Risk'),
        ('VERY_HIGH', 'Very High Risk'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    # tenant = models.ForeignKey(Tenant  # Temporarily commented, on_delete=models.CASCADE, related_name='payment_risk_assessments')
    
    # Associated Records
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE, related_name='payment_risk_assessments')
    invoice = models.OneToOneField(Invoice, on_delete=models.CASCADE, related_name='risk_assessment', null=True, blank=True)
    
    # Risk Assessment
    overall_risk_level = models.CharField(max_length=10, choices=RISK_LEVELS)
    risk_score = models.FloatField(help_text="AI risk score (0.0-1.0, higher = more risk)")
    payment_probability = models.FloatField(help_text="AI probability of payment (0.0-1.0)")
    
    # Timing Predictions
    predicted_payment_days = models.IntegerField(help_text="AI predicted days until payment")
    payment_behavior_category = models.CharField(
        max_length=20,
        choices=[
            ('EXCELLENT', 'Excellent'),
            ('GOOD', 'Good'),
            ('AVERAGE', 'Average'),
            ('POOR', 'Poor'),
            ('PROBLEMATIC', 'Problematic'),
        ]
    )
    
    # Risk Factors
    risk_factors = models.JSONField(default=list, help_text="AI-identified risk factors")
    protective_factors = models.JSONField(default=list, help_text="AI-identified protective factors")
    
    # Historical Analysis
    payment_history_analysis = models.JSONField(default=dict, help_text="Analysis of patient's payment history")
    similar_patient_analysis = models.JSONField(default=dict, help_text="Analysis based on similar patients")
    
    # Recommendations
    collection_strategy_recommendations = models.JSONField(default=list, help_text="AI recommended collection strategies")
    payment_plan_recommendations = models.JSONField(default=dict, help_text="AI recommended payment plans")
    
    # AI Metadata
    ai_model_version = models.CharField(max_length=20, default='1.0')
    confidence_score = models.FloatField(help_text="AI confidence in assessment")
    
    # Tracking
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Outcome Tracking
    actual_payment_date = models.DateField(null=True, blank=True)
    actual_payment_outcome = models.CharField(
        max_length=20,
        choices=[
            ('PAID_FULL', 'Paid in Full'),
            ('PAID_PARTIAL', 'Paid Partially'),
            ('PAYMENT_PLAN', 'Payment Plan'),
            ('COLLECTION', 'Sent to Collection'),
            ('WRITE_OFF', 'Written Off'),
        ],
        null=True, blank=True
    )
    prediction_accuracy = models.FloatField(null=True, blank=True, help_text="Accuracy of prediction")
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['patient', 'overall_risk_level']),
            models.Index(fields=['risk_score']),
            models.Index(fields=['payment_probability']),
            models.Index(fields=['created_at']),
        ]
    
    def __str__(self):
        return f"Payment Risk Assessment: {self.patient.get_full_name()} - {self.overall_risk_level}"
    
    def update_outcome(self, payment_date, outcome):
        """Update with actual payment outcome"""
        self.actual_payment_date = payment_date
        self.actual_payment_outcome = outcome
        
        # Calculate prediction accuracy
        if self.predicted_payment_days and payment_date:
            predicted_date = self.created_at.date() + timedelta(days=self.predicted_payment_days)
            actual_days = (payment_date - self.created_at.date()).days
            day_variance = abs(actual_days - self.predicted_payment_days)
            
            # Accuracy decreases with larger day variance
            day_accuracy = max(0, 1 - (day_variance / 30))  # 30-day tolerance
            
            # Outcome accuracy
            outcome_accuracy = 1.0 if outcome in ['PAID_FULL', 'PAID_PARTIAL'] else 0.5
            
            # Combined accuracy
            self.prediction_accuracy = (day_accuracy + outcome_accuracy) / 2
        
        self.save()