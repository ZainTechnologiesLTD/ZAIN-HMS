# apps/billing/models.py
from django.db import models
from django.utils import timezone
from django.core.validators import MinValueValidator
from decimal import Decimal
from datetime import timedelta
from apps.accounts.models import CustomUser as User
from apps.patients.models import Patient
from apps.appointments.models import Appointment
from apps.core.utils.serial_number import SerialNumberMixin
import uuid

class ServiceCategory(models.Model):
    """Categories for medical services"""
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    is_active = models.BooleanField(default=True)
    
    class Meta:
        ordering = ['name']
        verbose_name_plural = "Service Categories"
    
    def __str__(self):
        return self.name


class MedicalService(models.Model):
    """Medical services and their pricing"""
    category = models.ForeignKey(ServiceCategory, on_delete=models.CASCADE, related_name='services')
    code = models.CharField(max_length=20)
    name = models.CharField(max_length=200)
    description = models.TextField(blank=True)
    base_price = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(Decimal('0.00'))])
    duration_minutes = models.PositiveIntegerField(default=30)
    is_taxable = models.BooleanField(default=True)
    is_active = models.BooleanField(default=True)
    
    class Meta:
        ordering = ['name']
    
    def __str__(self):
        return f"{self.code} - {self.name}"


class Invoice(SerialNumberMixin):
    """Main invoice/bill model"""
    
    SERIAL_TYPE = 'bill'  # For automatic serial number generation
    STATUS_CHOICES = [
        ('DRAFT', 'Draft'),
        ('PENDING', 'Pending'),
        ('PARTIALLY_PAID', 'Partially Paid'),
        ('PAID', 'Paid'),
        ('OVERDUE', 'Overdue'),
        ('CANCELLED', 'Cancelled'),
        ('REFUNDED', 'Refunded'),
    ]
    
    PAYMENT_TERMS = [
        ('IMMEDIATE', 'Immediate'),
        ('NET_15', 'Net 15 Days'),
        ('NET_30', 'Net 30 Days'),
    ]
    
    # Basic Information
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    invoice_number = models.CharField(max_length=20, unique=True, blank=True)
    
    # Patient Information
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE, related_name='invoices')
    appointment = models.ForeignKey(Appointment, on_delete=models.SET_NULL, null=True, blank=True)
    
    # Invoice Details
    invoice_date = models.DateField(default=timezone.now)
    due_date = models.DateField()
    payment_terms = models.CharField(max_length=20, choices=PAYMENT_TERMS, default='IMMEDIATE')
    
    # Amounts
    subtotal = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    tax_rate = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal('0.00'))
    tax_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    discount_percentage = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal('0.00'))
    discount_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    total_amount = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    paid_amount = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    balance_amount = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    
    # Status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='DRAFT')
    
    # AI Enhancement Fields
    ai_generated = models.BooleanField(default=False, help_text="Invoice generated by AI")
    ai_confidence_score = models.FloatField(null=True, blank=True, help_text="AI confidence in billing accuracy (0.0-1.0)")
    ai_pricing_optimization = models.JSONField(default=dict, blank=True, help_text="AI pricing optimization data")
    ai_payment_prediction = models.JSONField(default=dict, blank=True, help_text="AI payment likelihood prediction")
    ai_revenue_insights = models.JSONField(default=dict, blank=True, help_text="AI revenue analysis and insights")
    
    # Insurance AI Processing
    insurance_verification_status = models.CharField(
        max_length=20,
        choices=[
            ('PENDING', 'Pending Verification'),
            ('VERIFIED', 'Verified'),
            ('REJECTED', 'Rejected'),
            ('PARTIAL', 'Partial Coverage'),
        ],
        default='PENDING'
    )
    insurance_ai_analysis = models.JSONField(default=dict, blank=True, help_text="AI insurance analysis results")
    
    # Payment AI Predictions
    predicted_payment_date = models.DateField(null=True, blank=True, help_text="AI predicted payment date")
    payment_risk_score = models.FloatField(null=True, blank=True, help_text="AI payment risk assessment (0.0-1.0)")
    
    # Notes
    notes = models.TextField(blank=True)
    internal_notes = models.TextField(blank=True)
    ai_notes = models.TextField(blank=True, help_text="AI-generated notes and recommendations")
    
    # Tracking
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='created_invoices')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Payment Information
    last_payment_date = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['invoice_number']),
            models.Index(fields=['status']),
            models.Index(fields=['due_date']),
            models.Index(fields=['patient']),
        ]
    
    def __str__(self):
        return f"Invoice {self.invoice_number} - {self.patient.get_full_name()}"
    
    def save(self, *args, **kwargs):
        if not self.invoice_number:
            self.invoice_number = self.generate_invoice_number()
        
        # Calculate totals
        self.calculate_totals()
        
        # Update status based on payments
        self.update_status()
        
        super().save(*args, **kwargs)
    
    def generate_invoice_number(self):
        """Generate unique invoice number"""
        from datetime import datetime
        
        today = datetime.now()
        date_str = today.strftime('%Y%m%d')
        
        last_invoice = Invoice.objects.filter(
            created_at__date=today.date()
        ).order_by('-created_at').first()
        
        if last_invoice and last_invoice.invoice_number:
            try:
                last_number = int(last_invoice.invoice_number.split('-')[-1])
                new_number = last_number + 1
            except:
                new_number = 1
        else:
            new_number = 1
        return f"INV-{date_str}-{new_number:04d}"
    
    def calculate_totals(self):
        """Calculate invoice totals"""
        self.subtotal = sum(item.total_amount for item in self.items.all())
        
        # Calculate discount
        if self.discount_percentage > 0:
            self.discount_amount = (self.subtotal * self.discount_percentage) / 100
        
        # Calculate tax on discounted amount
        taxable_amount = self.subtotal - self.discount_amount
        if self.tax_rate > 0:
            self.tax_amount = (taxable_amount * self.tax_rate) / 100
        
        # Calculate total
        self.total_amount = self.subtotal - self.discount_amount + self.tax_amount
        
        # Calculate balance
        self.balance_amount = self.total_amount - self.paid_amount
    
    def update_status(self):
        """Update invoice status based on payments"""
        if self.paid_amount <= 0:
            if self.due_date < timezone.now().date() and self.status == 'PENDING':
                self.status = 'OVERDUE'
            elif self.status not in ['DRAFT', 'CANCELLED', 'REFUNDED']:
                self.status = 'PENDING'
        elif self.paid_amount >= self.total_amount:
            self.status = 'PAID'
        else:
            self.status = 'PARTIALLY_PAID'
    
    def get_status_color(self):
        """Return Bootstrap color class for status"""
        colors = {
            'DRAFT': 'secondary',
            'PENDING': 'warning',
            'PARTIALLY_PAID': 'info',
            'PAID': 'success',
            'OVERDUE': 'danger',
            'CANCELLED': 'dark',
            'REFUNDED': 'primary',
        }
        return colors.get(self.status, 'secondary')


class InvoiceItem(models.Model):
    """Individual items on an invoice with AI enhancement"""
    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE, related_name='items')
    service = models.ForeignKey(MedicalService, on_delete=models.CASCADE, null=True, blank=True)
    
    # Service Details
    service_code = models.CharField(max_length=20, help_text="Service/procedure code")
    description = models.CharField(max_length=500)
    quantity = models.PositiveIntegerField(default=1)
    unit_price = models.DecimalField(max_digits=10, decimal_places=2)
    total_amount = models.DecimalField(max_digits=10, decimal_places=2)
    
    # AI Enhancement Fields
    ai_generated = models.BooleanField(default=False, help_text="Item identified by AI")
    ai_confidence = models.FloatField(null=True, blank=True, help_text="AI confidence in item accuracy")
    ai_source = models.CharField(max_length=50, blank=True, help_text="AI source (e.g., 'emr_analysis', 'text_extraction')")
    ai_extraction_details = models.JSONField(default=dict, blank=True, help_text="Details of AI extraction process")
    
    # Medical Coding
    icd_10_code = models.CharField(max_length=10, blank=True, help_text="ICD-10 diagnosis code")
    cpt_code = models.CharField(max_length=10, blank=True, help_text="CPT procedure code")
    ai_coding_confidence = models.FloatField(null=True, blank=True, help_text="AI confidence in medical coding")
    
    # Pricing Intelligence
    market_price_comparison = models.JSONField(default=dict, blank=True, help_text="AI market price analysis")
    pricing_optimization_applied = models.BooleanField(default=False)
    original_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    
    class Meta:
        ordering = ['id']
        indexes = [
            models.Index(fields=['service_code']),
            models.Index(fields=['ai_generated']),
            models.Index(fields=['icd_10_code']),
            models.Index(fields=['cpt_code']),
        ]
    
    def save(self, *args, **kwargs):
        self.total_amount = self.quantity * self.unit_price
        super().save(*args, **kwargs)
    
    def __str__(self):
        return f"{self.description} - {self.quantity} x {self.unit_price}"
    
    def get_ai_insights(self):
        """Get AI insights for this invoice item"""
        insights = []
        
        if self.ai_generated:
            insights.append(f"AI-identified with {self.ai_confidence:.1%} confidence")
        
        if self.pricing_optimization_applied and self.original_price:
            savings = self.original_price - self.unit_price
            if savings > 0:
                insights.append(f"AI pricing saved ${savings:.2f}")
        
        if self.market_price_comparison:
            market_avg = self.market_price_comparison.get('market_average', 0)
            if market_avg and self.unit_price < market_avg:
                insights.append("Competitively priced below market average")
        
        return insights


class Payment(models.Model):
    """Payment records for invoices"""
    PAYMENT_METHODS = [
        ('CASH', 'Cash'),
        ('CREDIT_CARD', 'Credit Card'),
        ('DEBIT_CARD', 'Debit Card'),
        ('CHECK', 'Check'),
        ('BANK_TRANSFER', 'Bank Transfer'),
        ('INSURANCE', 'Insurance'),
        ('ONLINE', 'Online Payment'),
        ('OTHER', 'Other'),
    ]
    
    STATUS_CHOICES = [
        ('PENDING', 'Pending'),
        ('COMPLETED', 'Completed'),
        ('FAILED', 'Failed'),
        ('CANCELLED', 'Cancelled'),
        ('REFUNDED', 'Refunded'),
    ]
    
    # Basic Information
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE, related_name='payments')
    payment_number = models.CharField(max_length=20, unique=True, blank=True)
    
    # Payment Details
    amount = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(Decimal('0.01'))])
    payment_method = models.CharField(max_length=20, choices=PAYMENT_METHODS)
    payment_date = models.DateTimeField(default=timezone.now)
    
    # Transaction Details
    transaction_id = models.CharField(max_length=100, blank=True)
    reference_number = models.CharField(max_length=100, blank=True)
    
    # Status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='COMPLETED')
    
    # Notes
    notes = models.TextField(blank=True)
    
    # Tracking
    processed_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='processed_payments')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-payment_date']
    
    def __str__(self):
        return f"Payment {self.payment_number} - {self.amount}"
    
    def save(self, *args, **kwargs):
        if not self.payment_number:
            self.payment_number = self.generate_payment_number()
        super().save(*args, **kwargs)
        
        # Update invoice paid amount
        self.update_invoice_payment()
    
    def generate_payment_number(self):
        """Generate unique payment number"""
        from datetime import datetime
        
        today = datetime.now()
        date_str = today.strftime('%Y%m%d')
        
        last_payment = Payment.objects.filter(
            created_at__date=today.date()
        ).order_by('-created_at').first()
        
        if last_payment and last_payment.payment_number:
            try:
                last_number = int(last_payment.payment_number.split('-')[-1])
                new_number = last_number + 1
            except:
                new_number = 1
        else:
            new_number = 1
            
        return f"PAY-{date_str}-{new_number:06d}"
    
    def update_invoice_payment(self):
        """Update invoice payment totals"""
        if self.status == 'COMPLETED':
            total_paid = self.invoice.payments.filter(status='COMPLETED').aggregate(
                total=models.Sum('amount')
            )['total'] or Decimal('0.00')
            
            self.invoice.paid_amount = total_paid
            self.invoice.last_payment_date = timezone.now()
            self.invoice.save(update_fields=['paid_amount', 'last_payment_date'])


class InsuranceClaim(models.Model):
    """Insurance claims for invoices"""
    STATUS_CHOICES = [
        ('SUBMITTED', 'Submitted'),
        ('UNDER_REVIEW', 'Under Review'),
        ('APPROVED', 'Approved'),
        ('REJECTED', 'Rejected'),
        ('PAID', 'Paid'),
    ]
    
    invoice = models.OneToOneField(Invoice, on_delete=models.CASCADE, related_name='insurance_claim')
    claim_number = models.CharField(max_length=50, unique=True, blank=True)
    
    # Insurance Details
    insurance_provider = models.CharField(max_length=200)
    policy_number = models.CharField(max_length=100)
    group_number = models.CharField(max_length=100, blank=True)
    
    # AI Enhancement for Insurance Claims
    ai_pre_authorization_check = models.JSONField(default=dict, blank=True, help_text="AI pre-authorization analysis")
    ai_approval_probability = models.FloatField(null=True, blank=True, help_text="AI prediction of claim approval")
    ai_processing_insights = models.JSONField(default=dict, blank=True, help_text="AI insights for claim processing")
    
    # Claim Details
    claim_amount = models.DecimalField(max_digits=10, decimal_places=2)
    approved_amount = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    deductible_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    
    # Status and Dates
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='SUBMITTED')
    submitted_date = models.DateField(auto_now_add=True)
    response_date = models.DateField(null=True, blank=True)
    
    # Notes
    notes = models.TextField(blank=True)
    rejection_reason = models.TextField(blank=True)
    
    # Tracking
    created_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return f"Claim {self.claim_number} - {self.insurance_provider}"
    
    def save(self, *args, **kwargs):
        if not self.claim_number:
            self.claim_number = self.generate_claim_number()
        super().save(*args, **kwargs)
    
    def generate_claim_number(self):
        """Generate unique claim number"""
        from datetime import datetime
        
        today = datetime.now()
        date_str = today.strftime('%Y%m%d')
        
        last_claim = InsuranceClaim.objects.filter(
            created_at__date=today.date()
        ).order_by('-created_at').first()
        
        if last_claim and last_claim.claim_number:
            try:
                last_number = int(last_claim.claim_number.split('-')[-1])
                new_number = last_number + 1
            except:
                new_number = 1
        else:
            new_number = 1
            
        return f"CLM-{date_str}-{new_number:05d}"


# Backwards-compatible alias: some modules expect a `Bill` model name.
# Keep `Bill` as a simple alias to `Invoice` to avoid breaking imports while
# the codebase is migrated to the `Invoice` name.
Bill = Invoice


class BillingAIInsights(models.Model):
    """
    AI-generated insights and analytics for billing operations
    """
    INSIGHT_TYPES = [
        ('REVENUE_FORECAST', 'Revenue Forecast'),
        ('PAYMENT_PREDICTION', 'Payment Prediction'),
        ('PRICING_OPTIMIZATION', 'Pricing Optimization'),
        ('COLLECTION_STRATEGY', 'Collection Strategy'),
        ('INSURANCE_ANALYSIS', 'Insurance Analysis'),
        ('MARKET_ANALYSIS', 'Market Analysis'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Insight Details
    insight_type = models.CharField(max_length=30, choices=INSIGHT_TYPES)
    title = models.CharField(max_length=200)
    description = models.TextField()
    
    # AI Analysis Data
    ai_data = models.JSONField(help_text="AI analysis data and metrics")
    confidence_score = models.FloatField(help_text="AI confidence in insight (0.0-1.0)")
    accuracy_score = models.FloatField(null=True, blank=True, help_text="Historical accuracy of similar insights")
    
    # Associated Records
    related_invoices = models.ManyToManyField(Invoice, blank=True, related_name='ai_insights')
    related_patients = models.ManyToManyField(Patient, blank=True, related_name='billing_ai_insights')
    
    # Impact Metrics
    potential_revenue_impact = models.DecimalField(max_digits=12, decimal_places=2, null=True, blank=True)
    implementation_priority = models.CharField(
        max_length=10,
        choices=[('LOW', 'Low'), ('MEDIUM', 'Medium'), ('HIGH', 'High'), ('CRITICAL', 'Critical')],
        default='MEDIUM'
    )
    
    # Status and Tracking
    is_implemented = models.BooleanField(default=False)
    implementation_notes = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField(null=True, blank=True, help_text="When this insight becomes stale")
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['insight_type', 'created_at']),
            models.Index(fields=['confidence_score']),
            models.Index(fields=['implementation_priority']),
        ]
    
    def __str__(self):
        return f"{self.insight_type}: {self.title}"
    
    def is_valid(self):
        """Check if insight is still valid/not expired"""
        if self.expires_at:
            return timezone.now() < self.expires_at
        return True


class RevenueAnalytics(models.Model):
    """
    AI-powered revenue analytics and forecasting
    """
    PERIOD_TYPES = [
        ('DAILY', 'Daily'),
        ('WEEKLY', 'Weekly'),
        ('MONTHLY', 'Monthly'),
        ('QUARTERLY', 'Quarterly'),
        ('YEARLY', 'Yearly'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Period Information
    period_type = models.CharField(max_length=10, choices=PERIOD_TYPES)
    period_start = models.DateField()
    period_end = models.DateField()
    
    # Revenue Metrics
    actual_revenue = models.DecimalField(max_digits=15, decimal_places=2, null=True, blank=True)
    predicted_revenue = models.DecimalField(max_digits=15, decimal_places=2)
    ai_confidence = models.FloatField(help_text="AI confidence in prediction")
    
    # Collection Metrics
    collection_rate = models.FloatField(null=True, blank=True, help_text="Actual collection rate as percentage")
    predicted_collection_rate = models.FloatField(help_text="AI predicted collection rate")
    
    # AI Analysis
    revenue_drivers = models.JSONField(default=list, help_text="AI-identified revenue drivers")
    risk_factors = models.JSONField(default=list, help_text="AI-identified risk factors")
    optimization_opportunities = models.JSONField(default=list, help_text="AI-identified optimization opportunities")
    
    # Forecasting Data
    forecast_data = models.JSONField(default=dict, help_text="Detailed AI forecast data")
    trend_analysis = models.JSONField(default=dict, help_text="AI trend analysis")
    
    # Performance Tracking
    accuracy_score = models.FloatField(null=True, blank=True, help_text="Accuracy of prediction (calculated after period)")
    variance_percentage = models.FloatField(null=True, blank=True, help_text="Variance from prediction")
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-period_start']
        indexes = [
            models.Index(fields=['period_start', 'period_end']),
            models.Index(fields=['period_type']),
            models.Index(fields=['ai_confidence']),
        ]
    
    def __str__(self):
        return f"{self.period_type} Revenue Analytics: {self.period_start} to {self.period_end}"
    
    def calculate_accuracy(self):
        """Calculate prediction accuracy after period ends"""
        if self.actual_revenue and self.predicted_revenue:
            variance = abs(self.actual_revenue - self.predicted_revenue)
            self.variance_percentage = float((variance / self.predicted_revenue) * 100)
            self.accuracy_score = max(0, 100 - self.variance_percentage) / 100
            return self.accuracy_score
        return None


class PaymentRiskAssessment(models.Model):
    """
    AI-powered payment risk assessment for patients and invoices
    """
    RISK_LEVELS = [
        ('VERY_LOW', 'Very Low Risk'),
        ('LOW', 'Low Risk'),
        ('MEDIUM', 'Medium Risk'),
        ('HIGH', 'High Risk'),
        ('VERY_HIGH', 'Very High Risk'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Associated Records
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE, related_name='payment_risk_assessments')
    invoice = models.OneToOneField(Invoice, on_delete=models.CASCADE, related_name='risk_assessment', null=True, blank=True)
    
    # Risk Assessment
    overall_risk_level = models.CharField(max_length=10, choices=RISK_LEVELS)
    risk_score = models.FloatField(help_text="AI risk score (0.0-1.0, higher = more risk)")
    payment_probability = models.FloatField(help_text="AI probability of payment (0.0-1.0)")
    
    # Timing Predictions
    predicted_payment_days = models.IntegerField(help_text="AI predicted days until payment")
    payment_behavior_category = models.CharField(
        max_length=20,
        choices=[
            ('EXCELLENT', 'Excellent'),
            ('GOOD', 'Good'),
            ('AVERAGE', 'Average'),
            ('POOR', 'Poor'),
            ('PROBLEMATIC', 'Problematic'),
        ]
    )
    
    # Risk Factors
    risk_factors = models.JSONField(default=list, help_text="AI-identified risk factors")
    protective_factors = models.JSONField(default=list, help_text="AI-identified protective factors")
    
    # Historical Analysis
    payment_history_analysis = models.JSONField(default=dict, help_text="Analysis of patient's payment history")
    similar_patient_analysis = models.JSONField(default=dict, help_text="Analysis based on similar patients")
    
    # Recommendations
    collection_strategy_recommendations = models.JSONField(default=list, help_text="AI recommended collection strategies")
    payment_plan_recommendations = models.JSONField(default=dict, help_text="AI recommended payment plans")
    
    # AI Metadata
    ai_model_version = models.CharField(max_length=20, default='1.0')
    confidence_score = models.FloatField(help_text="AI confidence in assessment")
    
    # Tracking
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # Outcome Tracking
    actual_payment_date = models.DateField(null=True, blank=True)
    actual_payment_outcome = models.CharField(
        max_length=20,
        choices=[
            ('PAID_FULL', 'Paid in Full'),
            ('PAID_PARTIAL', 'Paid Partially'),
            ('PAYMENT_PLAN', 'Payment Plan'),
            ('COLLECTION', 'Sent to Collection'),
            ('WRITE_OFF', 'Written Off'),
        ],
        null=True, blank=True
    )
    prediction_accuracy = models.FloatField(null=True, blank=True, help_text="Accuracy of prediction")
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['patient', 'overall_risk_level']),
            models.Index(fields=['risk_score']),
            models.Index(fields=['payment_probability']),
            models.Index(fields=['created_at']),
        ]
    
    def __str__(self):
        return f"Payment Risk Assessment: {self.patient.get_full_name()} - {self.overall_risk_level}"
    
    def update_outcome(self, payment_date, outcome):
        """Update with actual payment outcome"""
        self.actual_payment_date = payment_date
        self.actual_payment_outcome = outcome
        
        # Calculate prediction accuracy
        if self.predicted_payment_days and payment_date:
            predicted_date = self.created_at.date() + timedelta(days=self.predicted_payment_days)
            actual_days = (payment_date - self.created_at.date()).days
            day_variance = abs(actual_days - self.predicted_payment_days)
            
            # Accuracy decreases with larger day variance
            day_accuracy = max(0, 1 - (day_variance / 30))  # 30-day tolerance
            
            # Outcome accuracy
            outcome_accuracy = 1.0 if outcome in ['PAID_FULL', 'PAID_PARTIAL'] else 0.5
            
            # Combined accuracy
            self.prediction_accuracy = (day_accuracy + outcome_accuracy) / 2
        
        self.save()


# ===== POINT OF SALE (PoS) MODELS =====

class PoSCategory(models.Model):
    """Categories for PoS items (Medicines, Medical Supplies, Equipment, etc.)"""
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    icon = models.CharField(max_length=50, blank=True, help_text="CSS icon class name")
    color = models.CharField(max_length=7, default="#007bff", help_text="Hex color code")
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['name']
        verbose_name = "PoS Category"
        verbose_name_plural = "PoS Categories"
    
    def __str__(self):
        return self.name


class PoSItem(models.Model):
    """Items available in Point of Sale system"""
    
    ITEM_TYPES = [
        ('MEDICINE', 'Medicine'),
        ('MEDICAL_SUPPLY', 'Medical Supply'),
        ('EQUIPMENT', 'Medical Equipment'),
        ('SERVICE', 'Service'),
        ('CONSUMABLE', 'Consumable'),
        ('OTHER', 'Other'),
    ]
    
    category = models.ForeignKey(PoSCategory, on_delete=models.CASCADE, related_name='items')
    item_code = models.CharField(max_length=20, unique=True)
    name = models.CharField(max_length=200)
    description = models.TextField(blank=True)
    item_type = models.CharField(max_length=20, choices=ITEM_TYPES, default='OTHER')
    
    # Pricing
    cost_price = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(Decimal('0.00'))])
    selling_price = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(Decimal('0.00'))])
    discount_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    
    # Inventory
    current_stock = models.PositiveIntegerField(default=0)
    minimum_stock = models.PositiveIntegerField(default=5)
    maximum_stock = models.PositiveIntegerField(default=1000)
    
    # Settings
    is_taxable = models.BooleanField(default=True)
    tax_rate = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal('0.00'))
    is_active = models.BooleanField(default=True)
    is_prescription_required = models.BooleanField(default=False)
    
    # Tracking
    barcode = models.CharField(max_length=50, blank=True, unique=True, null=True)
    manufacturer = models.CharField(max_length=100, blank=True)
    batch_number = models.CharField(max_length=50, blank=True)
    expiry_date = models.DateField(null=True, blank=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['name']
        verbose_name = "PoS Item"
        verbose_name_plural = "PoS Items"
    
    def __str__(self):
        return f"{self.item_code} - {self.name}"
    
    @property
    def profit_margin(self):
        """Calculate profit margin percentage"""
        if self.cost_price > 0:
            return ((self.selling_price - self.cost_price) / self.cost_price) * 100
        return 0
    
    @property
    def is_low_stock(self):
        """Check if item is running low on stock"""
        return self.current_stock <= self.minimum_stock
    
    @property
    def is_expired(self):
        """Check if item is expired"""
        if self.expiry_date:
            return self.expiry_date < timezone.now().date()
        return False


class PoSTransaction(SerialNumberMixin):
    """Point of Sale transaction/sale"""
    
    SERIAL_TYPE = 'pos'
    
    PAYMENT_METHODS = [
        ('CASH', 'Cash'),
        ('CARD', 'Card'),
        ('DIGITAL', 'Digital Payment'),
        ('INSURANCE', 'Insurance'),
        ('CREDIT', 'Credit'),
        ('MIXED', 'Mixed Payment'),
    ]
    
    TRANSACTION_STATUS = [
        ('PENDING', 'Pending'),
        ('COMPLETED', 'Completed'),
        ('CANCELLED', 'Cancelled'),
        ('REFUNDED', 'Refunded'),
    ]
    
    # Basic Information
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    transaction_number = models.CharField(max_length=20, unique=True, blank=True)
    
    # Customer Information (optional for walk-in customers)
    patient = models.ForeignKey(Patient, on_delete=models.SET_NULL, null=True, blank=True, related_name='pos_transactions')
    customer_name = models.CharField(max_length=100, blank=True, help_text="For non-patient customers")
    customer_phone = models.CharField(max_length=15, blank=True)
    
    # Transaction Details
    transaction_date = models.DateTimeField(default=timezone.now)
    
    # Amounts
    subtotal = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    tax_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    discount_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    total_amount = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    
    # Payment Information
    payment_method = models.CharField(max_length=20, choices=PAYMENT_METHODS, default='CASH')
    amount_received = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    change_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    
    # Status
    status = models.CharField(max_length=20, choices=TRANSACTION_STATUS, default='PENDING')
    
    # Notes
    notes = models.TextField(blank=True)
    
    # Tracking
    cashier = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, related_name='pos_transactions')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = "PoS Transaction"
        verbose_name_plural = "PoS Transactions"
    
    def __str__(self):
        return f"PoS-{self.transaction_number} - {self.total_amount}"
    
    def save(self, *args, **kwargs):
        if not self.transaction_number:
            self.transaction_number = self.generate_transaction_number()
        
        # Calculate totals
        self.calculate_totals()
        
        super().save(*args, **kwargs)
    
    def generate_transaction_number(self):
        """Generate unique transaction number"""
        from datetime import datetime
        
        today = datetime.now()
        date_str = today.strftime('%Y%m%d')
        
        last_transaction = PoSTransaction.objects.filter(
            created_at__date=today.date()
        ).order_by('-created_at').first()
        
        if last_transaction and last_transaction.transaction_number:
            try:
                last_number = int(last_transaction.transaction_number.split('-')[-1])
                new_number = last_number + 1
            except:
                new_number = 1
        else:
            new_number = 1
        return f"POS-{date_str}-{new_number:04d}"
    
    def calculate_totals(self):
        """Calculate transaction totals"""
        self.subtotal = sum(item.total_amount for item in self.items.all())
        self.tax_amount = sum(item.tax_amount for item in self.items.all())
        self.total_amount = self.subtotal + self.tax_amount - self.discount_amount
        
        # Calculate change
        if self.amount_received > self.total_amount:
            self.change_amount = self.amount_received - self.total_amount
        else:
            self.change_amount = Decimal('0.00')


class PoSTransactionItem(models.Model):
    """Individual items in a PoS transaction"""
    
    transaction = models.ForeignKey(PoSTransaction, on_delete=models.CASCADE, related_name='items')
    item = models.ForeignKey(PoSItem, on_delete=models.CASCADE, related_name='transaction_items')
    
    # Quantity and Pricing
    quantity = models.PositiveIntegerField(default=1)
    unit_price = models.DecimalField(max_digits=10, decimal_places=2)
    discount_percentage = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal('0.00'))
    discount_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    
    # Calculated fields
    subtotal = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    tax_rate = models.DecimalField(max_digits=5, decimal_places=2, default=Decimal('0.00'))
    tax_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    total_amount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    
    # Prescription tracking (if required)
    prescription_number = models.CharField(max_length=50, blank=True)
    prescribed_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, limit_choices_to={'role': 'DOCTOR'})
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        verbose_name = "PoS Transaction Item"
        verbose_name_plural = "PoS Transaction Items"
    
    def __str__(self):
        return f"{self.item.name} x {self.quantity}"
    
    def save(self, *args, **kwargs):
        # Set unit price from item if not provided
        if not self.unit_price:
            self.unit_price = self.item.selling_price
        
        # Set tax rate from item if not provided
        if not self.tax_rate:
            self.tax_rate = self.item.tax_rate
        
        # Calculate amounts
        self.subtotal = self.quantity * self.unit_price
        
        # Apply discount
        if self.discount_percentage > 0:
            self.discount_amount = (self.subtotal * self.discount_percentage) / 100
        
        # Calculate tax on discounted amount
        taxable_amount = self.subtotal - self.discount_amount
        if self.tax_rate > 0 and self.item.is_taxable:
            self.tax_amount = (taxable_amount * self.tax_rate) / 100
        
        # Calculate total
        self.total_amount = taxable_amount + self.tax_amount
        
        super().save(*args, **kwargs)


class PoSDayClose(models.Model):
    """Daily cash register closing report"""
    
    date = models.DateField()
    cashier = models.ForeignKey(User, on_delete=models.CASCADE, related_name='pos_day_closes')
    
    # Cash Management
    opening_cash = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    closing_cash = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    cash_sales = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    cash_variance = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    
    # Sales Summary
    total_transactions = models.PositiveIntegerField(default=0)
    total_sales = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    total_tax = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    total_discount = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'))
    
    # Payment Method Breakdown
    cash_payments = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    card_payments = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    digital_payments = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    credit_sales = models.DecimalField(max_digits=12, decimal_places=2, default=Decimal('0.00'))
    
    # Status
    is_closed = models.BooleanField(default=False)
    notes = models.TextField(blank=True)
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-date']
        unique_together = ['date', 'cashier']
        verbose_name = "PoS Day Close"
        verbose_name_plural = "PoS Day Closes"
    
    def __str__(self):
        return f"Day Close - {self.date} - {self.cashier.get_full_name()}"